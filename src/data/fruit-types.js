// src/data/fruit-types.js - Devil Fruit Types and Elements for 128 Fruits

const FRUIT_TYPES = {
  // =====================================================
  // COMMON FRUITS
  // =====================================================
  "Mushi Mushi no Mi, Model: Suzumebachi": { type: 'Zoan', fruitType: 'Insect' },
  "Sara Sara no Mi, Model: Axolotl": { type: 'Zoan', fruitType: 'Amphibian' },
  "Batto Batto no Mi, Model: Vampire": { type: 'Zoan', fruitType: 'Vampire Bat' },
  "Tama Tama no Mi": { type: 'Zoan', fruitType: 'Egg' },
  "Mogu Mogu no Mi": { type: 'Zoan', fruitType: 'Mole' },
  "Inu Inu no Mi, Model: Tanuki": { type: 'Zoan', fruitType: 'Tanuki' },
  "Inu Inu no Mi, Model: Dachshund": { type: 'Zoan', fruitType: 'Dachshund' },
  "Neko Neko no Mi, Model: Saber Tiger": { type: 'Zoan', fruitType: 'Saber Tiger' },
  "Inu Inu no Mi, Model: Jackal": { type: 'Zoan', fruitType: 'Jackal' },
  "Uma Uma no Mi": { type: 'Zoan', fruitType: 'Horse' },
  "Ushi Ushi no Mi, Model: Giraffe": { type: 'Zoan', fruitType: 'Giraffe' },
  "Neko Neko no Mi, Model: Leopard": { type: 'Zoan', fruitType: 'Leopard' },
  "Inu Inu no Mi, Model: Wolf": { type: 'Zoan', fruitType: 'Wolf' },
  "Zou Zou no Mi": { type: 'Zoan', fruitType: 'Elephant' },
  "Tori Tori no Mi, Model: Falcon": { type: 'Zoan', fruitType: 'Falcon' },
  "Hito Hito no Mi": { type: 'Zoan', fruitType: 'Human' },
  "Ushi Ushi no Mi, Model: Bison": { type: 'Zoan', fruitType: 'Bison' },
  "Mushi Mushi no Mi, Model: Kabuto": { type: 'Zoan', fruitType: 'Beetle' },
  "Kame Kame no Mi": { type: 'Zoan', fruitType: 'Turtle' },
  "Tori Tori no Mi, Model: Eagle": { type: 'Zoan', fruitType: 'Eagle' },
  "Susu Susu no Mi": { type: 'Paramecia', fruitType: 'Soot' },
  "Shibo Shibo no Mi": { type: 'Paramecia', fruitType: 'Liquid' },
  "Nagi Nagi no Mi": { type: 'Paramecia', fruitType: 'Silence' },
  "Chiyu Chiyu no Mi": { type: 'Paramecia', fruitType: 'Healing' },
  "Memo Memo no Mi": { type: 'Paramecia', fruitType: 'Memory' },

  // =====================================================
  // UNCOMMON FRUITS
  // =====================================================
  "Sube Sube no Mi": { type: 'Paramecia', fruitType: 'Smooth' },
  "Supa Supa no Mi": { type: 'Paramecia', fruitType: 'Blade' },
  "Toge Toge no Mi": { type: 'Paramecia', fruitType: 'Spike' },
  "Ori Ori no Mi": { type: 'Paramecia', fruitType: 'Cage' },
  "Bane Bane no Mi": { type: 'Paramecia', fruitType: 'Spring' },
  "Noro Noro no Mi": { type: 'Paramecia', fruitType: 'Slow' },
  "Doa Doa no Mi": { type: 'Paramecia', fruitType: 'Door' },
  "Awa Awa no Mi": { type: 'Paramecia', fruitType: 'Bubble' },
  "Beta Beta no Mi": { type: 'Paramecia', fruitType: 'Sticky' },
  "Bari Bari no Mi": { type: 'Paramecia', fruitType: 'Barrier' },
  "Nui Nui no Mi": { type: 'Paramecia', fruitType: 'Stitch' },
  "Buku Buku no Mi": { type: 'Paramecia', fruitType: 'Book' },
  "Pero Pero no Mi": { type: 'Paramecia', fruitType: 'Candy' },
  "Bisu Bisu no Mi": { type: 'Paramecia', fruitType: 'Biscuit' },
  "Kuri Kuri no Mi": { type: 'Paramecia', fruitType: 'Cream' },
  "Mira Mira no Mi": { type: 'Paramecia', fruitType: 'Mirror' },
  "Maki Maki no Mi": { type: 'Paramecia', fruitType: 'Scroll' },
  "Oshi Oshi no Mi": { type: 'Paramecia', fruitType: 'Push' },
  "Fuku Fuku no Mi": { type: 'Paramecia', fruitType: 'Clothing' },
  "Juku Juku no Mi": { type: 'Paramecia', fruitType: 'Mature' },
  "Ryu Ryu no Mi, Model: Spinosaurus": { type: 'Ancient Zoan', fruitType: 'Spinosaurus' },
  "Ryu Ryu no Mi, Model: Pteranodon": { type: 'Ancient Zoan', fruitType: 'Pteranodon' },
  "Ryu Ryu no Mi, Model: Brachiosaurus": { type: 'Ancient Zoan', fruitType: 'Brachiosaurus' },
  "Ryu Ryu no Mi, Model: Allosaurus": { type: 'Ancient Zoan', fruitType: 'Allosaurus' },
  "Ryu Ryu no Mi, Model: Triceratops": { type: 'Ancient Zoan', fruitType: 'Triceratops' },

  // =====================================================
  // RARE FRUITS
  // =====================================================
  "Bara Bara no Mi": { type: 'Paramecia', fruitType: 'Separation' },
  "Bomu Bomu no Mi": { type: 'Paramecia', fruitType: 'Explosion' },
  "Kilo Kilo no Mi": { type: 'Paramecia', fruitType: 'Weight' },
  "Doru Doru no Mi": { type: 'Paramecia', fruitType: 'Wax' },
  "Baku Baku no Mi": { type: 'Paramecia', fruitType: 'Munch' },
  "Mane Mane no Mi": { type: 'Paramecia', fruitType: 'Clone' },
  "Shari Shari no Mi": { type: 'Paramecia', fruitType: 'Wheel' },
  "Beri Beri no Mi": { type: 'Paramecia', fruitType: 'Berry' },
  "Sabi Sabi no Mi": { type: 'Paramecia', fruitType: 'Rust' },
  "Shabon Shabon no Mi": { type: 'Paramecia', fruitType: 'Soap' },
  "Suke Suke no Mi": { type: 'Paramecia', fruitType: 'Clear' },
  "Kama Kama no Mi": { type: 'Paramecia', fruitType: 'Sickle' },
  "Horo Horo no Mi": { type: 'Paramecia', fruitType: 'Hollow' },
  "Yomi Yomi no Mi": { type: 'Paramecia', fruitType: 'Revive' },
  "Kage Kage no Mi": { type: 'Paramecia', fruitType: 'Shadow' },
  "Horu Horu no Mi": { type: 'Paramecia', fruitType: 'Hormone' },
  "Choki Choki no Mi": { type: 'Paramecia', fruitType: 'Scissors' },
  "Fuwa Fuwa no Mi": { type: 'Paramecia', fruitType: 'Float' },
  "Mero Mero no Mi": { type: 'Paramecia', fruitType: 'Love' },
  "Doku Doku no Mi": { type: 'Paramecia', fruitType: 'Poison' },
  "Hobi Hobi no Mi": { type: 'Paramecia', fruitType: 'Hobby' },
  "Hoya Hoya no Mi": { type: 'Paramecia', fruitType: 'Lamp' },
  "Netsu Netsu no Mi": { type: 'Paramecia', fruitType: 'Heat' },
  "Zushi Zushi no Mi": { type: 'Paramecia', fruitType: 'Gravity' },
  "Iba Iba no Mi": { type: 'Paramecia', fruitType: 'Thorn' },

  // =====================================================
  // EPIC FRUITS
  // =====================================================
  "Hana Hana no Mi": { type: 'Paramecia', fruitType: 'Flower' },
  "Kira Kira no Mi": { type: 'Paramecia', fruitType: 'Twinkle' },
  "Goe Goe no Mi": { type: 'Paramecia', fruitType: 'Voice' },
  "Kachi Kachi no Mi": { type: 'Paramecia', fruitType: 'Hardness' },
  "Nemu Nemu no Mi": { type: 'Paramecia', fruitType: 'Sleep' },
  "Mini Mini no Mi": { type: 'Paramecia', fruitType: 'Miniature' },
  "Atsu Atsu no Mi": { type: 'Paramecia', fruitType: 'Heat' },
  "Hiso Hiso no Mi": { type: 'Paramecia', fruitType: 'Whisper' },
  "Noko Noko no Mi": { type: 'Paramecia', fruitType: 'Spore' },
  "Ami Ami no Mi": { type: 'Paramecia', fruitType: 'Net' },
  "Kopi Kopi no Mi": { type: 'Paramecia', fruitType: 'Copy' },
  "Modo Modo no Mi": { type: 'Paramecia', fruitType: 'More' },
  "Mosa Mosa no Mi": { type: 'Paramecia', fruitType: 'Plant' },
  "Gasu Gasu no Mi": { type: 'Logia', fruitType: 'Gas' },
  "Yuki Yuki no Mi": { type: 'Logia', fruitType: 'Snow' },
  "Numa Numa no Mi": { type: 'Logia', fruitType: 'Swamp' },
  "Moku Moku no Mi": { type: 'Logia', fruitType: 'Smoke' },
  "Suna Suna no Mi": { type: 'Logia', fruitType: 'Sand' },
  "Hie Hie no Mi": { type: 'Logia', fruitType: 'Ice' },
  "Mera Mera no Mi": { type: 'Logia', fruitType: 'Fire' },
  "Goro Goro no Mi": { type: 'Logia', fruitType: 'Lightning' },
  "Peto Peto no Mi": { type: 'Paramecia', fruitType: 'Pet' },
  "Gunyo Gunyo no Mi": { type: 'Paramecia', fruitType: 'Slime' },

  // =====================================================
  // MYTHICAL FRUITS
  // =====================================================
  "Kage Kage no Mi": { type: 'Paramecia', fruitType: 'Shadow' },
  "Nikyu Nikyu no Mi": { type: 'Paramecia', fruitType: 'Paw' },
  "Hobi Hobi no Mi": { type: 'Paramecia', fruitType: 'Hobby' },
  "Ito Ito no Mi": { type: 'Paramecia', fruitType: 'String' },
  "Ope Ope no Mi": { type: 'Paramecia', fruitType: 'Op' },
  "Mochi Mochi no Mi": { type: 'Special Paramecia', fruitType: 'Mochi' },
  "Pika Pika no Mi": { type: 'Logia', fruitType: 'Light' },
  "Magu Magu no Mi": { type: 'Logia', fruitType: 'Magma' },
  "Tori Tori no Mi, Model: Phoenix": { type: 'Mythical Zoan', fruitType: 'Phoenix' },
  "Hito Hito no Mi, Model: Daibutsu": { type: 'Mythical Zoan', fruitType: 'Great Buddha' },
  "Hebi Hebi no Mi, Model: Yamata-no-Orochi": { type: 'Mythical Zoan', fruitType: 'Eight-Headed Serpent' },
  "Inu Inu no Mi, Model: Okuchi no Makami": { type: 'Mythical Zoan', fruitType: 'Wolf God' },
  "Inu Inu no Mi, Model: Kyubi no Kitsune": { type: 'Mythical Zoan', fruitType: 'Nine-Tailed Fox' },
  "Zou Zou no Mi, Model: Mammoth": { type: 'Ancient Zoan', fruitType: 'Mammoth' },
  "Mori Mori no Mi": { type: 'Logia', fruitType: 'Forest' },

  // =====================================================
  // LEGENDARY FRUITS
  // =====================================================
  "Soru Soru no Mi": { type: 'Paramecia', fruitType: 'Soul' },
  "Gomu Gomu no Mi": { type: 'Paramecia', fruitType: 'Rubber' },
  "Toki Toki no Mi": { type: 'Paramecia', fruitType: 'Time' },
  "Uo Uo no Mi, Model: Seiryu": { type: 'Mythical Zoan', fruitType: 'Azure Dragon' },
  "Ryu Ryu no Mi, Model: Kirin": { type: 'Mythical Zoan', fruitType: 'Kirin' },
  "Wara Wara no Mi": { type: 'Paramecia', fruitType: 'Straw' },
  "Ura Ura no Mi": { type: 'Paramecia', fruitType: 'Warp' },
  "Shima Shima no Mi": { type: 'Paramecia', fruitType: 'Island' },

  // =====================================================
  // DIVINE FRUITS
  // =====================================================
  "Gura Gura no Mi": { type: 'Paramecia', fruitType: 'Tremor' },
  "Hito Hito no Mi, Model: Nika": { type: 'Mythical Zoan', fruitType: 'Sun God' },
  "Yami Yami no Mi": { type: 'Logia', fruitType: 'Darkness' }
};

// Type counters - which elements are effective against others
const TYPE_COUNTERS = {
  // Elemental counters
  'Fire': ['Ice', 'Snow', 'Wax', 'Flower', 'Plant'],
  'Ice': ['Fire', 'Magma', 'Heat'],
  'Water': ['Fire', 'Magma', 'Sand'],
  'Lightning': ['Water', 'Ice', 'Cage'],
  'Earth': ['Lightning', 'Fire'],
  'Wind': ['Earth', 'Sand'],
  'Light': ['Darkness', 'Shadow'],
  'Darkness': ['Light'],
  'Magma': ['Ice', 'Snow'],
  'Sand': ['Water'],
  'Poison': ['Healing'],
  'Gravity': ['Float'],
  'Time': ['Space'],
  'Space': ['Time'],
  'Soul': ['Hollow'],
  'Death': ['Soul', 'Revive'],
  'Chaos': ['Order'],
  'Order': ['Chaos'],
  'Reality': ['Illusion'],
  'Void': ['Creation'],
  'Creation': ['Void'],
  'Sun God': ['All'], // Beats everything except itself
  'Liberation': ['All'], // Ultimate freedom
  'Tremor': ['All'], // World-shaking power
  
  // Physical counters
  'Blade': ['Rubber', 'Separation'],
  'Blunt': ['Spike', 'Hardness'],
  'Separation': ['String', 'Stitch'],
  'Explosion': ['Barrier', 'Wax'],
  'Weight': ['Float', 'Spring'],
  'Spring': ['Sticky', 'Cage'],
  'Sticky': ['Smooth', 'Blade'],
  'Smooth': ['Spike', 'Thorn'],
  'Spike': ['Balloon', 'Rubber'],
  'Cage': ['Key', 'Door'],
  'Door': ['Wall', 'Barrier'],
  'Barrier': ['Penetration', 'Phase'],
  
  // Conceptual counters
  'Love': ['Asexual', 'Machine'],
  'Fear': ['Courage', 'Madness'],
  'Memory': ['Amnesia', 'Time'],
  'Copy': ['Original', 'Unique'],
  'Illusion': ['Truth', 'Light'],
  'Dream': ['Reality', 'Awakening'],
  'Sleep': ['Awakening', 'Insomnia'],
  'Silence': ['Voice', 'Sound'],
  'Invisibility': ['Light', 'Heat'],
  'Phase': ['Solid', 'Dense'],
  
  // Special counters
  'Hobby': ['Seriousness', 'Adult'],
  'Toy': ['Memory', 'Growth'],
  'String': ['Cut', 'Burn'],
  'Mirror': ['Darkness', 'Absorption'],
  'Book': ['Illiteracy', 'Digital'],
  'Scroll': ['Fire', 'Water'],
  'Clone': ['Original', 'Unique'],
  'Transform': ['Lock', 'Curse'],
  'Rust': ['Stainless', 'Plastic'],
  'Age': ['Youth', 'Time'],
  'Mature': ['Youth', 'Preserve'],
  'Wither': ['Life', 'Heal'],
  'Decay': ['Preserve', 'Life'],
  'Heal': ['Poison', 'Curse'],
  'Purify': ['Corrupt', 'Dirty'],
  'Bless': ['Curse', 'Evil'],
  'Curse': ['Bless', 'Holy'],
  'Holy': ['Evil', 'Demon'],
  'Evil': ['Holy', 'Angel'],
  'Divine': ['Mortal', 'Sin'],
  'Mortal': ['Divine', 'Eternal'],
  'Eternal': ['Mortal', 'End'],
  'Infinite': ['Finite', 'Limit'],
  'Perfect': ['Flaw', 'Incomplete'],
  'Absolute': ['Relative', 'Conditional']
};

// Type effectiveness multipliers
const TYPE_EFFECTIVENESS = {
  SUPER_EFFECTIVE: 1.5,
  NORMAL: 1.0,
  NOT_VERY_EFFECTIVE: 0.7,
  NO_EFFECT: 0.5
};

// Type emojis
const TYPE_EMOJIS = {
  'Paramecia': '🔮',
  'Logia': '🌪️',
  'Zoan': '🐺',
  'Ancient Zoan': '🦕',
  'Mythical Zoan': '🐉',
  'Special Paramecia': '✨',
  'Divine Zoan': '☀️',
  'Dual Fruit': '⚡',
  
  // Element emojis
  'Fire': '🔥',
  'Ice': '❄️',
  'Water': '🌊',
  'Lightning': '⚡',
  'Earth': '🌍',
  'Wind': '💨',
  'Light': '☀️',
  'Darkness': '🌑',
  'Magma': '🌋',
  'Sand': '🏜️',
  'Poison': '☠️',
  'Gravity': '🌌',
  'Time': '⏰',
  'Space': '🌠',
  'Soul': '👻',
  'Death': '💀',
  'Chaos': '🌪️',
  'Reality': '🔮',
  'Void': '⚫',
  'Creation': '✨',
  'Sun God': '☀️',
  'Liberation': '🎺',
  'Tremor': '💥',
  'Rubber': '🟡',
  'Separation': '✂️',
  'Explosion': '💣',
  'Weight': '⚖️',
  'Wax': '🕯️',
  'Spring': '🌸',
  'Blade': '⚔️',
  'Spike': '🔺',
  'Cage': '🔒',
  'Munch': '👄',
  'Clone': '👥',
  'Flower': '🌸',
  'Wheel': '⚙️',
  'Berry': '🫐',
  'Rust': '🦠',
  'Soap': '🧼',
  'Clear': '🫥',
  'Sickle': '🗡️',
  'Hollow': '👻',
  'Revive': '💀',
  'Shadow': '🌚',
  'Hormone': '💉',
  'Scissors': '✂️',
  'Float': '🎈',
  'Love': '💕',
  'Hobby': '🧸',
  'Lamp': '🪔',
  'Heat': '🌡️',
  'Thorn': '🌹',
  'Twinkle': '✨',
  'Voice': '🗣️',
  'Hardness': '💎',
  'Sleep': '😴',
  'Miniature': '🔍',
  'Whisper': '🤫',
  'Spore': '🍄',
  'Net': '🕸️',
  'Copy': '📋',
  'More': '➕',
  'Plant': '🌱',
  'Gas': '💨',
  'Snow': '❄️',
  'Swamp': '🏞️',
  'Smoke': '💨',
  'Pet': '🐕',
  'Slime': '🟢',
  'Paw': '🐾',
  'String': '🧵',
  'Op': '🏥',
  'Mochi': '🍡',
  'Phoenix': '🔥',
  'Great Buddha': '🏛️',
  'Eight-Headed Serpent': '🐍',
  'Wolf God': '🐺',
  'Nine-Tailed Fox': '🦊',
  'Mammoth': '🐘',
  'Forest': '🌳',
  'Azure Dragon': '🐉',
  'Kirin': '🦄',
  'Straw': '🌾',
  'Warp': '🌀',
  'Island': '🏝️'
};

// Utility functions
function getFruitType(fruitName) {
  return FRUIT_TYPES[fruitName] || { type: 'Paramecia', fruitType: 'Unknown' };
}

function getTypeMatchup(attackingType, defendingType) {
  const counters = TYPE_COUNTERS[attackingType];
  if (!counters) return TYPE_EFFECTIVENESS.NORMAL;
  
  if (counters.includes(defendingType)) {
    return TYPE_EFFECTIVENESS.SUPER_EFFECTIVE;
  }
  
  // Check if defending type counters attacking type
  const defenderCounters = TYPE_COUNTERS[defendingType];
  if (defenderCounters && defenderCounters.includes(attackingType)) {
    return TYPE_EFFECTIVENESS.NOT_VERY_EFFECTIVE;
  }
  
  return TYPE_EFFECTIVENESS.NORMAL;
}

function getFruitsByType(type) {
  return Object.entries(FRUIT_TYPES)
    .filter(([fruitName, typeData]) => typeData.type === type)
    .map(([fruitName, typeData]) => ({ fruitName, ...typeData }));
}

function getFruitsByElement(element) {
  return Object.entries(FRUIT_TYPES)
    .filter(([fruitName, typeData]) => typeData.fruitType === element)
    .map(([fruitName, typeData]) => ({ fruitName, ...typeData }));
}

function getAllFruitTypes() {
  const types = new Set();
  Object.values(FRUIT_TYPES).forEach(typeData => {
    types.add(typeData.type);
  });
  return Array.from(types);
}

function getAllElements() {
  const elements = new Set();
  Object.values(FRUIT_TYPES).forEach(typeData => {
    elements.add(typeData.fruitType);
  });
  return Array.from(elements);
}

function getTypeEmoji(type) {
  return TYPE_EMOJIS[type] || '❓';
}

function calculateBattleEffectiveness(attackerFruitName, defenderFruitName) {
  const attackerType = getFruitType(attackerFruitName);
  const defenderType = getFruitType(defenderFruitName);
  
  const effectiveness = getTypeMatchup(attackerType.fruitType, defenderType.fruitType);
  
  let message = '';
  if (effectiveness === TYPE_EFFECTIVENESS.SUPER_EFFECTIVE) {
    message = 'It\'s super effective!';
  } else if (effectiveness === TYPE_EFFECTIVENESS.NOT_VERY_EFFECTIVE) {
    message = 'It\'s not very effective...';
  } else if (effectiveness === TYPE_EFFECTIVENESS.NO_EFFECT) {
    message = 'It has no effect...';
  } else {
    message = 'Normal effectiveness';
  }
  
  return {
    effectiveness,
    message,
    attackerType: attackerType.fruitType,
    defenderType: defenderType.fruitType
  };
}

function getTypeInfo(type) {
  const emoji = getTypeEmoji(type);
  const counters = TYPE_COUNTERS[type] || [];
  const weakTo = Object.entries(TYPE_COUNTERS)
    .filter(([counterType, targets]) => targets.includes(type))
    .map(([counterType]) => counterType);
  
  return {
    name: type,
    emoji,
    strongAgainst: counters,
    weakAgainst: weakTo,
    description: getTypeDescription(type)
  };
}

function getTypeDescription(type) {
  const descriptions = {
    'Fire': 'Burns through ice and nature',
    'Ice': 'Freezes water and slows lightning',
    'Lightning': 'Conducts through water and metal',
    'Water': 'Extinguishes fire and erodes earth',
    'Earth': 'Grounds lightning and absorbs fire',
    'Light': 'Banishes darkness and shadows',
    'Darkness': 'Consumes light and creates fear',
    'Time': 'Controls the flow of temporal reality',
    'Space': 'Manipulates dimensional boundaries',
    'Soul': 'Affects the essence of life',
    'Death': 'The ultimate end of all things',
    'Reality': 'Bends the laws of existence',
    'Sun God': 'Divine power that liberates all',
    'Liberation': 'Freedom from all constraints',
    'Tremor': 'World-shaking destructive force'
  };
  return descriptions[type] || 'A mysterious power with unknown properties';
}

function getTypeStats() {
  const typeDistribution = {};
  const elementDistribution = {};
  
  Object.values(FRUIT_TYPES).forEach(typeData => {
    typeDistribution[typeData.type] = (typeDistribution[typeData.type] || 0) + 1;
    elementDistribution[typeData.fruitType] = (elementDistribution[typeData.fruitType] || 0) + 1;
  });
  
  return {
    total: Object.keys(FRUIT_TYPES).length,
    typeDistribution,
    elementDistribution,
    uniqueTypes: Object.keys(typeDistribution).length,
    uniqueElements: Object.keys(elementDistribution).length
  };
}

function validateTypeData() {
  const errors = [];
  
  Object.entries(FRUIT_TYPES).forEach(([fruitName, typeData]) => {
    if (!typeData.type) errors.push(`Missing type for fruit: ${fruitName}`);
    if (!typeData.fruitType) errors.push(`Missing fruitType for fruit: ${fruitName}`);
  });
  
  return {
    isValid: errors.length === 0,
    errors,
    totalFruits: Object.keys(FRUIT_TYPES).length
  };
}

function getElementCounterChain(element) {
  const counters = TYPE_COUNTERS[element] || [];
  const weakTo = Object.entries(TYPE_COUNTERS)
    .filter(([type, targets]) => targets.includes(element))
    .map(([type]) => type);
  
  return {
    element,
    strongAgainst: counters,
    weakAgainst: weakTo,
    emoji: getTypeEmoji(element)
  };
}

function getBalancedTypeMatchups() {
  const matchups = {};
  
  Object.keys(TYPE_COUNTERS).forEach(attackType => {
    matchups[attackType] = {};
    Object.keys(TYPE_COUNTERS).forEach(defendType => {
      matchups[attackType][defendType] = getTypeMatchup(attackType, defendType);
    });
  });
  
  return matchups;
}

function getElementalAdvantageMatrix() {
  const matrix = {};
  const allElements = getAllElements();
  
  allElements.forEach(attacker => {
    matrix[attacker] = {};
    allElements.forEach(defender => {
      const effectiveness = getTypeMatchup(attacker, defender);
      matrix[attacker][defender] = effectiveness;
    });
  });
  
  return matrix;
}

function findElementalCounterRecommendations(userElements) {
  const recommendations = [];
  const elementCounts = {};
  
  // Count user's elements
  userElements.forEach(element => {
    elementCounts[element] = (elementCounts[element] || 0) + 1;
  });
  
  // Find weaknesses
  Object.keys(elementCounts).forEach(element => {
    const weakTo = Object.entries(TYPE_COUNTERS)
      .filter(([type, targets]) => targets.includes(element))
      .map(([type]) => type);
    
    if (weakTo.length > 0) {
      const recommendedCounters = [];
      weakTo.forEach(weakness => {
        const counters = TYPE_COUNTERS[weakness] || [];
        recommendedCounters.push(...counters);
      });
      
      recommendations.push({
        element,
        weaknesses: weakTo,
        recommendedCounters: [...new Set(recommendedCounters)]
      });
    }
  });
  
  return recommendations;
}

module.exports = {
  FRUIT_TYPES,
  TYPE_COUNTERS,
  TYPE_EFFECTIVENESS,
  TYPE_EMOJIS,
  getFruitType,
  getTypeMatchup,
  getFruitsByType,
  getFruitsByElement,
  getAllFruitTypes,
  getAllElements,
  getTypeEmoji,
  calculateBattleEffectiveness,
  getTypeInfo,
  getTypeDescription,
  getTypeStats,
  validateTypeData,
  getElementCounterChain,
  getBalancedTypeMatchups,
  getElementalAdvantageMatrix,
  findElementalCounterRecommendations
};
